---
title: "How I Built a Gen 3 Save Parser in the Browser"
publishedAt: "2026-02-20"
summary: "Decrypting Pokemon save files with XOR keys, shuffling sub-structures by PID, and extracting bit-packed IVs from raw binary data — all in JavaScript."
author: "Basil Francis Alajid"
tags: ["webdev", "pokemon", "binary", "javascript"]
image: "/me.jpg"
---

# How I Built a Gen 3 Save Parser in the Browser

One of the features I'm most proud of in **Professor Basil's Lab** is the ability to import your actual Pokemon from a GBA emulator save file directly into the web app. You drag a `.sav` file into the browser, and seconds later your team is sitting there, stats and all, ready for the battle simulator. Getting there meant reverse-engineering a binary format that Game Freak designed in 2002 with no intention of anyone reading it from JavaScript.

This post walks through how Gen 3 Pokemon save data is structured, how I decrypt and parse it, and the gnarliest bits (literally) of working with bit-packed fields in the browser.

## Why Parse Save Files at All?

Professor Basil's Lab already has a team builder where you can create Pokemon from scratch. But I wanted a bridge between the GBA emulator that runs inside the app (more on that in another post) and the rest of the experience. When you catch a Torchic in the emulator, you should be able to pull it into the battle simulator or view its summary without manually re-entering its data. That means reading the emulator's SRAM dump and extracting every Pokemon from the party and PC boxes.

## Reading Binary Data in JavaScript

The browser gives us `ArrayBuffer` and `DataView`, which are exactly what we need for structured binary access. When the user provides a `.sav` file, I read it with the File API and wrap it in a `DataView`:

```typescript
async function loadSaveFile(file: File): Promise<DataView> {
  const buffer = await file.arrayBuffer();
  return new DataView(buffer);
}
```

`DataView` lets you read integers at arbitrary byte offsets with explicit endianness. Gen 3 is little-endian throughout, so every read looks like `view.getUint32(offset, true)` where `true` means little-endian. This is important — get it wrong and every value is garbage.

## The Gen 3 Pokemon Data Structure

Each Pokemon in Gen 3 (Ruby, Sapphire, Emerald, FireRed, LeafGreen) is stored as an **80-byte block**. The first 32 bytes are an unencrypted header containing the Personality Value (PID), Original Trainer ID (OTID), nickname, and a few flags. The remaining 48 bytes are **encrypted** and split into four **12-byte sub-structures** labeled G (Growth), A (Attacks), E (EVs/Condition), and M (Miscellaneous).

```
Bytes 0-3:    PID (Personality Value)
Bytes 4-7:    OTID (Original Trainer ID)
Bytes 8-17:   Nickname (10 characters, Gen 3 encoding)
Bytes 18-19:  Language
Bytes 20-31:  Other header fields
Bytes 32-79:  Encrypted data (4 sub-structures x 12 bytes)
```

The sub-structures contain everything interesting: species ID, held item, moves, EVs, IVs, experience, and ability. But you cannot just read them in order. Game Freak scrambled them.

## Decryption: The XOR Key

The 48 encrypted bytes are XOR-encrypted using a key derived from the PID and OTID. The key is simply `PID XOR OTID`, and you apply it in 4-byte chunks across the entire 48-byte region:

```typescript
function decryptSubstructures(
  data: DataView,
  offset: number,
  pid: number,
  otid: number
): ArrayBuffer {
  const key = (pid ^ otid) >>> 0;
  const decrypted = new ArrayBuffer(48);
  const view = new DataView(decrypted);

  for (let i = 0; i < 48; i += 4) {
    const encrypted = data.getUint32(offset + 32 + i, true);
    view.setUint32(i, (encrypted ^ key) >>> 0, true);
  }

  return decrypted;
}
```

The `>>> 0` coerces to an unsigned 32-bit integer, which matters because JavaScript's bitwise operators work on signed 32-bit ints. Without it, you get negative values that corrupt the XOR.

## Sub-Structure Shuffling

Here is where it gets really fun. The four sub-structures (G, A, E, M) are not stored in a fixed order. Their order depends on `PID % 24`, which gives one of 24 possible permutations. Game Freak did this to make save editing harder, and honestly, it works.

I hardcoded a lookup table for all 24 permutations. Each entry maps the storage position to the logical sub-structure:

```typescript
const SUBSTRUCTURE_ORDER: readonly (readonly number[])[] = [
  [0, 1, 2, 3], // 0:  G A E M
  [0, 1, 3, 2], // 1:  G A M E
  [0, 2, 1, 3], // 2:  G E A M
  [0, 2, 3, 1], // 3:  G E M A
  [0, 3, 1, 2], // 4:  G M A E
  [0, 3, 2, 1], // 5:  G M E A
  [1, 0, 2, 3], // 6:  A G E M
  [1, 0, 3, 2], // 7:  A G M E
  [1, 2, 0, 3], // 8:  A E G M
  [1, 2, 3, 0], // 9:  A E M G
  [1, 3, 0, 2], // 10: A M G E
  [1, 3, 2, 0], // 11: A M E G
  [2, 0, 1, 3], // 12: E G A M
  [2, 0, 3, 1], // 13: E G M A
  [2, 1, 0, 3], // 14: E A G M
  [2, 1, 3, 0], // 15: E A M G
  [2, 3, 0, 1], // 16: E M G A
  [2, 3, 1, 0], // 17: E M A G
  [3, 0, 1, 2], // 18: M G A E
  [3, 0, 2, 1], // 19: M G E A
  [3, 1, 0, 2], // 20: M A G E
  [3, 1, 2, 0], // 21: M A E G
  [3, 2, 0, 1], // 22: M E G A
  [3, 2, 1, 0], // 23: M E A G
] as const;

function getSubstructure(
  decrypted: DataView,
  pid: number,
  target: number // 0=G, 1=A, 2=E, 3=M
): DataView {
  const order = SUBSTRUCTURE_ORDER[pid % 24];
  const position = order.indexOf(target);
  const offset = position * 12;
  return new DataView(decrypted.buffer, offset, 12);
}
```

I spent an embarrassing amount of time debugging a case where the order table itself was correct but I had the lookup direction backwards — I was indexing *into* the target instead of *finding* the target in the array. Off-by-one errors have nothing on off-by-direction errors.

## Bit-Packed IV Extraction

Individual Values (IVs) are the hidden stats that make each Pokemon unique. In Gen 3, all six IVs are packed into a single 32-bit integer inside the Miscellaneous sub-structure. Each IV is 5 bits wide (values 0-31), and they are packed as follows:

```
Bits  0-4:   HP
Bits  5-9:   Attack
Bits 10-14:  Defense
Bits 15-19:  Speed
Bits 20-24:  Special Attack
Bits 25-29:  Special Defense
Bit  30:     Is Egg flag
Bit  31:     Has Species (ability bit in some contexts)
```

Extracting them is straightforward with bitmasks:

```typescript
function extractIVs(miscView: DataView): PokemonIVs {
  const ivData = miscView.getUint32(4, true);

  return {
    hp:    (ivData >>  0) & 0x1F,
    atk:   (ivData >>  5) & 0x1F,
    def:   (ivData >> 10) & 0x1F,
    speed: (ivData >> 15) & 0x1F,
    spa:   (ivData >> 20) & 0x1F,
    spd:   (ivData >> 25) & 0x1F,
  };
}
```

The `& 0x1F` mask (binary `11111`) isolates exactly 5 bits at each position. Simple once you know the layout, maddening to debug when you don't.

## Reading Species, Held Item, and EVs

From the Growth sub-structure (G), I pull the species ID and held item:

```typescript
function readGrowth(growthView: DataView) {
  return {
    species: growthView.getUint16(0, true),
    heldItem: growthView.getUint16(2, true),
    experience: growthView.getUint32(4, true),
  };
}
```

EVs live in the EVs/Condition sub-structure (E), stored as individual bytes since each ranges from 0 to 255:

```typescript
function readEVs(evView: DataView) {
  return {
    hp:    evView.getUint8(0),
    atk:   evView.getUint8(1),
    def:   evView.getUint8(2),
    speed: evView.getUint8(3),
    spa:   evView.getUint8(4),
    spd:   evView.getUint8(5),
  };
}
```

Species IDs map to an index in the National Pokedex, but Gen 3 uses its own internal ordering that doesn't match the Pokedex number. I maintain a lookup table that maps the internal ID to the national Dex number, which then maps to all the metadata (name, types, base stats) that the rest of the app needs.

## Bringing It All Together

The full import pipeline looks like this: read the `.sav` file, locate the party data (or iterate all 14 PC boxes), decrypt each 80-byte Pokemon block, unshuffle the sub-structures, extract every field, map the species ID to our internal data model, and push the result into the app's state. The whole thing runs in under 50 milliseconds for a full save file.

Working on this parser gave me a deep appreciation for how much data Game Freak crammed into 80 bytes per Pokemon. It also gave me a healthy fear of bit shifting in JavaScript. But the result — dragging a save file into the browser and watching your team appear — is one of those moments that makes all the binary headaches worth it.
